# my_project/main.py
import argparse
import os, csv
import cv2, numpy as np
from utils.zig_zag import *
from utils.dct import *
from utils.dwt import *
from utils.performance_metrices import *
from utils.filtering_attacks import *
from utils.geometrical_attacks import *
from utils.image_enhancement_attacks import *
from utils.noise_attacks import *
from utils.jpeg_compression import *
from scipy.ndimage import convolve

len_w=128
d=4096
d_=128
W = np.random.choice([1,-1], size=len_w)
n = 1
m = np.arange(2, len_w+2)
Top = np.zeros((n, len(m)))
# print("Top is ", Top)
for o in range(n):
    Top[o, :] = np.random.permutation(m)
print(Top)
index=np.

def encode(Y, alpha, L=2):
    m,n = Y.shape

    dwt_2l = dwt(Y, L) 

    ll2 = dwt_2l[0:m//2**L, 0:n//2**L]

    ll2_dct=dct(dct(ll2.T).T)

    ll2_and_zig_zag = zig_zag(ll2_dct)
    
    z = ll2_and_zig_zag.shape[0]//2

    v1 = ll2_and_zig_zag[0::2]/d
    v2 = ll2_and_zig_zag[1::2]/d

    v1_w=np.copy(v1)
    v2_w=np.copy(v2)

    v1_w[index] = 0.5*(v1[index] + v2[index]) + alpha*W
    v2_w[index] = 0.5*(v1[index] + v2[index]) - alpha*W

    ll2_and_zig_zag_new = np.zeros(2*z)
    ll2_and_zig_zag_new[0::2]=v1_w
    ll2_and_zig_zag_new[1::2]=v2_w

    ll2_new = zag_zig(ll2_and_zig_zag_new, m//2**L, n//2**L)

    ll2_new_idct=idct(idct(ll2_new.T).T)

    dwt_2l[0:m//2**L, 0:n//2**L] = ll2_new_idct

    Y_new = idwt(dwt_2l, L)

    return Y_new

def decode(Y_new, L=2):
    m,n = Y_new.shape

    dwt_2l = dwt(Y_new, L) 

    ll2 = dwt_2l[0:m//2**L, 0:n//2**L]

    ll2_dct=dct(dct(ll2.T).T)

    ll2_and_zig_zag = zig_zag(ll2_dct)

    z=ll2_and_zig_zag.shape[0]//2
    
    v1 = ll2_and_zig_zag[0::2]/d_
    v2 = ll2_and_zig_zag[1::2]/d_
    
    W_=v1[index] - v2[index]
    
    W_dec = np.where(W_ <= 0, -1, np.where(W_ > 0, 1, 0))

    return W_dec

def attacks(Y_new, atk_type):
    Y_atks = {}
    W_decs = {}
    if(atk_type=="filtering_attacks"):
        Y_atks["avgFilter"] = avgFilter(Y_new)
        W_decs["avgFilter"] = decode(Y_atks["avgFilter"])

        # Y_atks["medianFilter"] = medianFilter(Y_new)
        # W_decs["medianFilter"] = decode(Y_atks["medianFilter"])

        for index, (key, value) in enumerate(Y_atks.items()):
            print('/////////////////////////////////////////////////////////////////////////')
            print("\n",key)
            # print("Watermark from attacked image: \n", W_decs[key].astype(np.uint8))
            print("BCR of attacked image is: ", bcr(W, W_decs[key]))
            print("PSNR of attacked image is: ", psnr(Y_new, value))
            print("SSIM of attacked image is: ", ssim(Y_new, value))
    
#     Y_atk_gaussian = gaussianFilter2(Y_new)
#     print("datatype of gaussian attacked image is: ", Y_atk_gaussian.dtype)
#     # cv2.imshow("Median_atk.jpg", Y_atk_median)
#     W_dec = decode(Y_atk_gaussian)
#     csv_file_path = 'gaussian_atked_image.csv'
#     with open(csv_file_path, 'w', newline='') as file:
#         writer = csv.writer(file)
#         writer.writerows(Y_atk_gaussian)
#     print("Watermark from attacked image: \n", W_dec)
#     print("Gaussian attack: ")
#     print("BCR of attacked image is: ", bcr(W, W_dec))
#     print("PSNR of attacked image is: ", psnr(Y_new, Y_atk_gaussian))
#     print("SSIM of attacked image is: ", ssim(Y_new, Y_atk_gaussian))

#     Y_atk_jpeg_compression = jpeg_compression(Y_new, 20)
#     print("datatype of jpeg compressed image is: ", Y_atk_jpeg_compression.dtype)
#     # cv2.imshow("Median_atk.jpg", Y_atk_median)
#     W_dec = decode(Y_atk_jpeg_compression, len_w)
#     csv_file_path = 'jpeg_compressed_image.csv'
#     with open(csv_file_path, 'w', newline='') as file:
#         writer = csv.writer(file)
#         writer.writerows(Y_atk_jpeg_compression)
#     print("Watermark from attacked image: \n", W_dec)
#     print("JPEG_compression attack: ")
#     print("BCR of attacked image is: ", bcr(W, W_dec))
#     print("PSNR of attacked image is: ", psnr(Y_new, Y_atk_gaussian))
#     print("SSIM of attacked image is: ", ssim(Y_new, Y_atk_gaussian))
    






def wm2dwt():
    # Set up argument parsing for a single argument (image path)
    parser = argparse.ArgumentParser(description="Command-line tool for watermarking an image using 2DWT.")
    parser.add_argument("image_path", type=str, help="Path to the image file")
    parser.add_argument("-a", type=str, default=None, metavar="atk", help="Type of attack to check on the image")
    parser.add_argument("-l", type=int, default=2, metavar="L", help="Level of DWT to use for embedding the watermark")
    parser.add_argument("--alpha", type=int, default=0.1, metavar="alpha", help="Gain index for the watermark")
    parser.add_argument("-z","--len_w", type=int, default=64, metavar="len_w", help="length of watermark")

    try:
        args = parser.parse_args()
    except:
        # If there is any error, print the help message
        parser.print_help()
        return

    args = parser.parse_args()
    # Check if the file exists and has a valid image extension
    if not os.path.isfile(args.image_path):
        raise FileNotFoundError(f"File '{args.image_path}' does not exist.")
    
    valid_extensions = {".jpg", ".jpeg", ".png", ".bmp", ".tiff"}
    _, ext = os.path.splitext(args.image_path)
    if ext.lower() not in valid_extensions:
        raise ValueError("The provided file is not a valid image format.")

    # Attempt to load the image to verify itâ€™s a readable image file
    image = cv2.imread(args.image_path)
    if image is None:
        raise ValueError("The provided file could not be read as an image.")



    print("\nImage loaded successfully. Proceeding with processing...\n")
    print("size of original image is : ", image.shape)
    # ycrcb_img = cv2.cvtColor(image, cv2.COLOR_BGR2YCrCb)
    # Y, Cr, Cb = cv2.split(ycrcb_img)
    image = cv2.resize(image, (512,512), interpolation=cv2.INTER_LINEAR)
    print("size of image is : ", image.shape)
    ycrcb_img = cv2.cvtColor(image, cv2.COLOR_BGR2YCrCb)
    Y, Cr, Cb = cv2.split(ycrcb_img)
    # cv2.imshow("gray_image_wm.jpeg", Y)
    Y = Y.astype(np.float64)

    csv_file_path = 'original_image.csv'
    with open(csv_file_path, 'w', newline='') as file:
        writer = csv.writer(file)
        writer.writerows(Y)
    print("datatype of original image is: ", Y.dtype)

    alpha = 0.1
    # len_w = args.len_w
    L = args.l
    Y_new = encode(Y, alpha)
    print("datatype of Y_new image is: ", Y_new.dtype)
    print("Random watermark is:\n", W)
    print("////////////////////////////////////////////////////////////////////")
    cv2.imshow("watermarked_img.jpeg", Y_new.astype(np.uint8))
    # t1=dwt(Y_new,2)[0:4,0:4]
    # print(t1)
    # result=Y_new.copy()
    # for i in range(1,31):
    #     for j in range(1,31):
    #         neighborhood = Y_new[i-1:i+2, j-1:j+2]
    #         result[i, j] = np.mean(neighborhood)

    # cv2.imshow("watermarked_img_blurred.jpeg", Y_new.astype(np.uint8))
    # t2=dwt(result,2)[0:4,0:4]
    # print(t2)
    # print(np.mean((t2-t1)**2))
    # kernel = np.ones((25,1)) / 25

    # Apply convolution to compute the average
    # averaged_image = convolve(Y_new, kernel, mode='constant', cval=0.0)

    # cv2.imshow("watermarked_img_blurred.jpeg", result.astype(np.uint8))

    W_dec = decode(Y_new)
    
    # w_dec = decode(result)
    # print("Decoded watermark is:\n", w_dec)
    print("bcr of unattacked image is ", bcr(W, W_dec))
    # print("psnr to Y is ", psnr(Y, Y_new))
    print('////////////////////////////////////////////////////////////////////////////')
    atk_type = "filtering_attacks"
    attacks(Y_new, atk_type)

    cv2.waitKey(0)
    cv2.destroyAllWindows
    
# Ensure wm2dwt() runs when this script is called directly
if __name__ == "__main__":
    try:
        wm2dwt()
    except ValueError as e:
        print(e)



        # Embed the watermark into the coefficients using mod2 embedding
def embed_mod2(coeff_image, coeff_watermark, offset=0):
    for i in range(len(coeff_watermark)):
        for j in range(len(coeff_watermark[i])):
            coeff_image[i*2+offset][j*2+offset] = coeff_watermark[i][j]
    return coeff_image



    
# Embed the watermark into the coefficients using mod4 embedding
def embed_mod4(coeff_image, coeff_watermark):
    for i in range(len(coeff_watermark)):
        for j in range(len(coeff_watermark[i])):
            coeff_image[i*4][j*4] = coeff_watermark[i][j]
    return coeff_image
